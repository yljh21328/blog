<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chris Yang | 學習筆記</title><link>http://yljh21328.github.io/blog/</link><description></description><atom:link href="http://yljh21328.github.io/blog/feeds/chris-yang.rss.xml" rel="self"></atom:link><lastBuildDate>Sat, 12 Jul 2014 16:50:16 +0800</lastBuildDate><item><title>[retext] Retext 的安裝與設定</title><link>http://yljh21328.github.io/blog/posts/2014/07/retext/[retext]_retext_install_and_configure.html</link><description>&lt;p&gt;Retext 是一個好用的 Markdown 編輯器&lt;/p&gt;
&lt;p&gt;支援同步瀏覽&lt;/p&gt;
&lt;p&gt;內建  apt-get  所安裝的版本是2.0&lt;/p&gt;
&lt;p&gt;如果要安裝  4.0的話&lt;/p&gt;
&lt;p&gt;安裝方式如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;repository&lt;/span&gt; &lt;span class="n"&gt;ppa&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mitya57&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;retext&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果是  ubuntu 12.04  安裝的話會有  dependency&lt;/p&gt;
&lt;p&gt;可以用  &lt;code&gt;aptitude&lt;/code&gt;  來解決缺少python3-pyqt4的問題&lt;/p&gt;
&lt;p&gt;aptitude  會提供幾種策略解決，在筆者的環境是先按 N  再按  Y  &lt;/p&gt;
&lt;p&gt;使用第二種策略才解決成功&lt;/p&gt;
&lt;p&gt;參考來源：&lt;a href="http://www.webupd8.org/2012/03/retext-30-released-text-editor-for.html" target="_blank"&gt;ReText 3.0 Released (Text Editor For Markdown And reStructuredText)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝好之後 Retext  本身對於  markdown  的  css 跟 github 上差很多&lt;/p&gt;
&lt;p&gt;所以要做以下設定&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ReText&lt;/span&gt; &lt;span class="n"&gt;Project&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ReText&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;General&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;useReST&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;
&lt;span class="n"&gt;defaultExt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;md&lt;/span&gt;
&lt;span class="n"&gt;useWebkit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="n"&gt;styleSheet&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;自己的家目錄&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ReText&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;css&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;github.css  可以到  &lt;a href="https://gist.github.com/andyferra/2554919" target="_blank"&gt;github.css&lt;/a&gt;  下載&lt;/p&gt;
&lt;p&gt;如此就可以得到支援  github css  格式的  markdownn編輯器&lt;/p&gt;
&lt;p&gt;參考來源：&lt;a href="http://whatever1992.blog.163.com/blog/static/21783208820134212303582/" target="_blank"&gt;配置Retext&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Sat, 12 Jul 2014 16:50:16 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-12:blog/posts/2014/07/retext/[retext]_retext_install_and_configure.html</guid></item><item><title>[linux] Gnome3 與 Extensions</title><link>http://yljh21328.github.io/blog/posts/2014/07/linux/[linux]_gnome3_with_extensions.html</link><description>&lt;p&gt;Ubuntu 12.04  預設的桌面是 Unity&lt;/p&gt;
&lt;p&gt;而習慣 Gnome 2  或想嘗試  Gnome 3  的朋友可以用下列指令安裝&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;repository&lt;/span&gt; &lt;span class="n"&gt;ppa&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;gnome3&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;team&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gnome3&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;
&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;gnome&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;shell&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;參考來源：&lt;a href="http://www.filiwiese.com/installing-gnome-on-ubuntu-12-04-precise-pangolin/" target="_blank"&gt;Installing Gnome 3 on Ubuntu 12.04 (Precise Pangolin)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝完之後就有 Gnome  與 Gnome classic  可以選了&lt;/p&gt;
&lt;p&gt;而 Gnome 3  有一個很好玩的東西&lt;/p&gt;
&lt;p&gt;叫做 Gnome Shell Extensions&lt;/p&gt;
&lt;p&gt;所有的 Extensions  都是用  javascript  寫的&lt;/p&gt;
&lt;p&gt;而安裝 extension  的方式非常簡單&lt;/p&gt;
&lt;p&gt;只要到  &lt;a href="https://extensions.gnome.org/" target="_blank"&gt;GNOME Shell Extensions&lt;/a&gt;  點選安裝即可&lt;/p&gt;
&lt;p&gt;下面列一下所有我安裝的extensions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Advanced Settings in UserMenu&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這個可以開啟Gnome3的進階設定&lt;/p&gt;
&lt;p&gt;但是要先安裝 gnome-tweak-tool&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install gnome-tweak-tool&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Advanced Volume Mixer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alternative Status Menu&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Axe Menu&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coverflow Alt-Tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dash to Dock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Extension List&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hot-Corn-Dog&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安裝這個原本左上角的  Activity Hot Corner  會跑到左下角&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Impatience&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加速 gnome-shell animation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Places Status Indicator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Removable Drive Menu&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Remove Accessibility&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Remove Activities Button&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Show Desktop Button&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Weather&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Window options&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;參考來源：&lt;a href="http://maxubuntu.blogspot.tw/2012/09/debian-gnome3.html" target="_blank"&gt;Debian Gnome3桌面筆記&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Sat, 12 Jul 2014 16:24:31 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-12:blog/posts/2014/07/linux/[linux]_gnome3_with_extensions.html</guid></item><item><title>[linux] 修改 apt 的 mirror site</title><link>http://yljh21328.github.io/blog/posts/2014/07/linux/[linux]_apt_mirror_site.html</link><description>&lt;p&gt;安裝 ubuntu 預設的更新源是 &lt;code&gt;tw.archive.ubuntu.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;這個source 又慢又不穩定&lt;/p&gt;
&lt;p&gt;利用以下的步驟就可以幫 ubuntu 換一個最佳的更新源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cp /etc/apt/sources.list /etc/apt/sources.list.backup&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sudo /usr/bin/software-properties-gtk&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tab 選 "Ubuntu軟體"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下載自選擇 ""其它"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然後跑 "選擇最佳的伺服器"&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跑完就有最佳的更新源了&lt;/p&gt;
&lt;p&gt;參考來源：&lt;a href="http://blog.longwin.com.tw/2011/02/ubuntu-mirror-site-repository-2011/"&gt;Ubuntu Linux 挑選最佳的 Mirror Site (APT Repository) &lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 23:19:00 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/linux/[linux]_apt_mirror_site.html</guid></item><item><title>[pelican] 安裝 Pelican</title><link>http://yljh21328.github.io/blog/posts/2014/07/pelican/[pelican]_pelican_install.html</link><description>&lt;p&gt;Pelican 是一個 python 寫的 static site generator&lt;/p&gt;
&lt;p&gt;可以將產出的網頁放到 github page 上&lt;/p&gt;
&lt;p&gt;安裝過程可參考 &lt;a href="http://docs.getpelican.com/en/3.3.0/getting_started.html#kickstart-your-site" target="_blank"&gt;Installing Pelican&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在此紀錄幾個重要的步驟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安裝 pelican &lt;code&gt;sudo pip install pelican&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 Markdown &lt;code&gt;sudo pip install markdown&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 ghp-import &lt;code&gt;sudo pip install ghp-import&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著就可以下 &lt;code&gt;pelican-quickstart&lt;/code&gt; 來自動產生資料夾&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/pelican/[pelican]_pelican_install.html</guid></item><item><title>[research] Hilbert Curve</title><link>http://yljh21328.github.io/blog/posts/2014/07/research/[research]_hilbert_curve.html</link><description>&lt;p&gt;令 N = 2^n&lt;/p&gt;
&lt;p&gt;在一個 size 為 N x N 的二維空間中&lt;/p&gt;
&lt;p&gt;Hilbert curve 會遞迴地將我們的空間切成四個相同size 的 blocks&lt;/p&gt;
&lt;p&gt;而每一個 block 我們都會給一個 0 ~ N^2 -1 的number&lt;/p&gt;
&lt;p&gt;&lt;img src="http://yljh21328.github.io/blog/images/hilbert_curve.png" /&gt;&lt;/p&gt;
&lt;p&gt;舉例來說&lt;/p&gt;
&lt;p&gt;order n = 1 時我們可以得到一串分別是 0 ~ 3 的數字&lt;/p&gt;
&lt;p&gt;而 order n = 2 則是由 order n = 1 演化而來&lt;/p&gt;
&lt;p&gt;只要將order n = 1 的第一個 block 與最後一個 block 做 reflection 跟 rotation 即可得到結果&lt;/p&gt;
&lt;p&gt;依此類推&lt;/p&gt;
&lt;p&gt;order n = 3 是由 order n = 2 演化而來, 做的是相似的 reflection 與 rotation&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/research/[research]_hilbert_curve.html</guid></item><item><title>[research] The Bucket Numbering Scheme</title><link>http://yljh21328.github.io/blog/posts/2014/07/research/[research]_the_bucket_numbering_scheme.html</link><description>&lt;p&gt;一個空間上的物件可以是任意形狀&lt;/p&gt;
&lt;p&gt;而通常我們會取一個 bounding rectangle 來表示這個物件&lt;/p&gt;
&lt;p&gt;而坐標可利用 Xl, Xr, Yb, Yt四個屬性來定義&lt;/p&gt;
&lt;p&gt;在此我們用 L(Xl,Yb) 與 U(Xr,Yt) 來表示一個物件&lt;/p&gt;
&lt;p&gt;在 Bucket Number Scheme 裡面我們將一個 Bucket 以 0 或 1 來表示&lt;/p&gt;
&lt;p&gt;也稱作 &lt;font style="color:red;"&gt;DZ expression&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;表示的規則有兩點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在x軸中的0表示左半部, 1表示右半步。而在y軸中0表示下半部, 1表示上半部&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;越左邊的bit 代表越前面的binary division, 越後面的bit 代表越裡面的division&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="http://yljh21328.github.io/blog/images/dz_expression.png" /&gt;&lt;/p&gt;
&lt;p&gt;以圖中的例子&lt;/p&gt;
&lt;p&gt;舉例來說 0010* 表示的是&lt;/p&gt;
&lt;p&gt;00代表的是整個區塊裡面的左半部及下半部&lt;/p&gt;
&lt;p&gt;10代表的是左半部及下半部中，右半部及下半部&lt;/p&gt;
&lt;p&gt;以此類推。&lt;/p&gt;
&lt;p&gt;而在此我們也會使用 Max_bucket 來記錄所有bucket 中最大的 bucket number&lt;/p&gt;
&lt;p&gt;&lt;img src="http://yljh21328.github.io/blog/images/peano_curve.png" /&gt;&lt;/p&gt;
&lt;p&gt;在 Fig.6(a) 中我們將 binary form 轉成 decimal form&lt;/p&gt;
&lt;p&gt;而在 Fig.6(b) 中我們可以依照順序劃線來得到 N-order peano curve&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/research/[research]_the_bucket_numbering_scheme.html</guid></item><item><title>[search] binary search</title><link>http://yljh21328.github.io/blog/posts/2014/07/search/[search]_binary_search.html</link><description>&lt;p&gt;binary search 是一種用於事先排序好的資料的搜尋演算法&lt;/p&gt;
&lt;p&gt;算是 &lt;font style="color:red;"&gt;divide and conquer&lt;/font&gt; 的變形 (少了 merge 的步驟)&lt;/p&gt;
&lt;p&gt;核心概念於訂定三個 index : low, mid, high&lt;/p&gt;
&lt;p&gt;如果要找的 key 大於 data[mid], 則搜尋右半邊&lt;/p&gt;
&lt;p&gt;如果小於 data[mid] 則搜尋左半邊&lt;/p&gt;
&lt;p&gt;否則回傳mid 的位置&lt;/p&gt;
&lt;p&gt;一直找下去&lt;/p&gt;
&lt;p&gt;如果 high &amp;lt; low 則代表找尋不到&lt;/p&gt;
&lt;p&gt;因其每次可以prune 掉一半的資料&lt;/p&gt;
&lt;p&gt;所以其時間複雜度為 O(n log n)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SEARCH/binary_search/binary_search.java" target="_blank"&gt;binary search – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/search/[search]_binary_search.html</guid></item><item><title>[search] fibonacci search</title><link>http://yljh21328.github.io/blog/posts/2014/07/search/[search]_fibonacci_search.html</link><description>&lt;p&gt;fibonacci search 跟 binary search 一樣都是使用二分法來進行切割範圍和搜尋&lt;/p&gt;
&lt;p&gt;不同的是 fibonacci 是用 &lt;font style="color:red;"&gt;fibonacci number&lt;/font&gt; 來切割&lt;/p&gt;
&lt;p&gt;也就是說我們會先建立一個 fibonacci tree&lt;/p&gt;
&lt;p&gt;然後再依照此 tree 來做search&lt;/p&gt;
&lt;p&gt;示意圖 – &lt;a href="http://puremonkey2010.blogspot.tw/2010/12/blog-post.html" target="_blank"&gt;來源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://yljh21328.github.io/blog/images/fibonacci_tree.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;fibonacci tree 的 root 是由資料個數 n 決定的&lt;/p&gt;
&lt;p&gt;先利用 Fib(k+1) &amp;gt;= n + 1&lt;/p&gt;
&lt;p&gt;來決定 k&lt;/p&gt;
&lt;p&gt;再以Fib(k) 當作root 的值&lt;/p&gt;
&lt;p&gt;而其左子樹為 (k – 1) 階Fibonacci tree&lt;/p&gt;
&lt;p&gt;右子樹為 (k-2) 階 Fibonacci tree&lt;/p&gt;
&lt;p&gt;依此類推可以建立完整的 Fibonacci tree&lt;/p&gt;
&lt;p&gt;更多詳細資料可參考 – &lt;a href="http://puremonkey2010.blogspot.tw/2010/12/blog-post.html" target="_blank"&gt;程式扎記&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/search/[search]_fibonacci_search.html</guid></item><item><title>[search] interpolation search</title><link>http://yljh21328.github.io/blog/posts/2014/07/search/[search]_interpolation_search.html</link><description>&lt;p&gt;interpolation search 為 binary search 的改良版&lt;/p&gt;
&lt;p&gt;適合用在資料平均分佈的狀況下&lt;/p&gt;
&lt;p&gt;其內插法公式為&lt;/p&gt;
&lt;p&gt;mid = low + ((key – data[low]) / (data[high] – data[low])) * (high – low)&lt;/p&gt;
&lt;p&gt;而其餘的搜尋步驟則與 binary search 差不多&lt;/p&gt;
&lt;p&gt;平均而言其時間複雜度優於 &lt;code&gt;O(log n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SEARCH/interpolation_search/interpolation_search.java" target="_blank"&gt;interpolation search – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/search/[search]_interpolation_search.html</guid></item><item><title>[search] linear search</title><link>http://yljh21328.github.io/blog/posts/2014/07/search/[search]_linear_search.html</link><description>&lt;p&gt;linear search 是一個最簡單的搜尋方法&lt;/p&gt;
&lt;p&gt;又稱為 sequential search&lt;/p&gt;
&lt;p&gt;其搜尋方式就是從頭搜到尾&lt;/p&gt;
&lt;p&gt;worst case 的時間複雜度為 &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SEARCH/linear_search/linear_search.java" target="_blank"&gt;linear search – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/search/[search]_linear_search.html</guid></item><item><title>[sort] bubble sort</title><link>http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_bubble_sort.html</link><description>&lt;p&gt;bubble sort 是一種 internal sort&lt;/p&gt;
&lt;p&gt;適合資料量小或已經有初步排序的資料使用&lt;/p&gt;
&lt;p&gt;其 worst case 為 &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果是要由小排到大&lt;/p&gt;
&lt;p&gt;核心概念是由前往後兩兩比對，若前者大於後者則交換&lt;/p&gt;
&lt;p&gt;並由較大者繼續與後面的元素兩兩比對。&lt;/p&gt;
&lt;p&gt;每scan一次能確定一個元素的最後位置&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/traditional_bubble_sort/bubble_sort.java" target="_blank"&gt;傳統版 - JAVA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/better_bubble_sort/bubble_sort.java" target="_blank"&gt;改良版 - JAVA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在改良版的bubble sort 裡加入了 flag 來判斷該次 scan 有沒有做 swap&lt;/p&gt;
&lt;p&gt;如果沒有則不需要額外的 scan&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_bubble_sort.html</guid></item><item><title>[sort] heap sort</title><link>http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_heap_sort.html</link><description>&lt;p&gt;heap sort 使用了 heap 來幫助我們做sort 的工作&lt;/p&gt;
&lt;p&gt;時間複雜度為 &lt;code&gt;O(n logn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;為穩定排序法&lt;/p&gt;
&lt;p&gt;核心概念為運用heap 的特性&lt;/p&gt;
&lt;p&gt;假設我們有一個 size 為 n 的 heap&lt;/p&gt;
&lt;p&gt;每次將root 與heap 的最後一個位置交換&lt;/p&gt;
&lt;p&gt;然後再執行一次 size 為 n-1 的 &lt;font style="color:red;"&gt;heapify()&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;重複此動作直至所有元素都被排序完為止&lt;/p&gt;
&lt;p&gt;在實作的部分&lt;/p&gt;
&lt;p&gt;我們習慣將存data 的陣列的第0個位置空出來&lt;/p&gt;
&lt;p&gt;從第1個位置開始存&lt;/p&gt;
&lt;p&gt;這樣才能符合 heap 的特性&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/heap_sort/heap_sort.java" target="_blank"&gt;heap sort – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_heap_sort.html</guid></item><item><title>[sort] insertion sort</title><link>http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_insertion_sort.html</link><description>&lt;p&gt;insertion sort 是一個 internal sort&lt;/p&gt;
&lt;p&gt;其worst case 的時間複雜度為 &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要由小排到大&lt;/p&gt;
&lt;p&gt;核心概念為逐次檢查元素與其之前元素的大小&lt;/p&gt;
&lt;p&gt;如果比之前的元素小則將前面的元素往後推&lt;/p&gt;
&lt;p&gt;直到找到正確的位置為止&lt;/p&gt;
&lt;p&gt;因為在 scan 的過程中會發生多次的搬移&lt;/p&gt;
&lt;p&gt;所以如果以 linked list 來實作的話會快很多&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/insertion_sort/insertion_sort.java" target="_blank"&gt;Array版 – Java&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_insertion_sort.html</guid></item><item><title>[sort] merge sort</title><link>http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_merge_sort.html</link><description>&lt;p&gt;merge sort 是一個 external sort&lt;/p&gt;
&lt;p&gt;其時間複雜度為 &lt;code&gt;O(n logn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;適合合併多個檔案並排序&lt;/p&gt;
&lt;p&gt;如果有兩個檔案要做排序&lt;/p&gt;
&lt;p&gt;核心概念是先分別對這倆個檔案做內部排序&lt;/p&gt;
&lt;p&gt;之後再分別用指標指著這兩個檔案&lt;/p&gt;
&lt;p&gt;依序讀入後比較&lt;/p&gt;
&lt;p&gt;並將較小的元素給存到一個新的 sequence當中&lt;/p&gt;
&lt;p&gt;而該檔案繼續讀下一個元素&lt;/p&gt;
&lt;p&gt;直到讀完為止&lt;/p&gt;
&lt;p&gt;而如果其中一個檔案先讀完&lt;/p&gt;
&lt;p&gt;則直接將另外一個檔案的內容依序讀入sequence&lt;/p&gt;
&lt;p&gt;直至兩個檔案都讀完為止&lt;/p&gt;
&lt;p&gt;如此我們就可以得到一個排序過後的sequence&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/tree/master/SORT/direct_merge_sort" target="_blank"&gt;直接merge – JAVA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/tree/master/SORT/complete_merge_sort" target="_blank"&gt;分割檔案後再merge – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_merge_sort.html</guid></item><item><title>[sort] quick sort</title><link>http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_quick_sort.html</link><description>&lt;p&gt;quick sort 是一個內部排序法&lt;/p&gt;
&lt;p&gt;平均時間複雜度為 &lt;code&gt;O(n logn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;worst case 的時間複雜度為 O(n^2)&lt;/p&gt;
&lt;p&gt;採取的是 &lt;font stlye="color:red;"&gt;divide and conquer&lt;/font&gt; 的模式來解決問題&lt;/p&gt;
&lt;p&gt;核心概念是先設整個序列的第一個值為K&lt;/p&gt;
&lt;p&gt;然後從左至右找到一個比K 大的元素 Ki&lt;/p&gt;
&lt;p&gt;並從右到左找到一個比K小的元素Kj&lt;/p&gt;
&lt;p&gt;找到後就彼此交換&lt;/p&gt;
&lt;p&gt;直到 i &amp;lt; j 時&lt;/p&gt;
&lt;p&gt;此時再將 Kj 與 K 的位置交換&lt;/p&gt;
&lt;p&gt;結束這回合&lt;/p&gt;
&lt;p&gt;此時便能決定K的位置&lt;/p&gt;
&lt;p&gt;然後再利用divide and conquer 來解決左邊與右邊尚未解決的subsequence&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/quick_sort/quick_sort.java" target="_blank"&gt;quick sort – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_quick_sort.html</guid></item><item><title>[sort] radix sort</title><link>http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_radix_sort.html</link><description>&lt;p&gt;radix sort 是一個不需要兩兩比較元素的一種排序法&lt;/p&gt;
&lt;p&gt;其核心概念是透過分配每一個元素到適當的位置&lt;/p&gt;
&lt;p&gt;我們可以先從最低位數開始比較或從最高位數開始比較都可以&lt;/p&gt;
&lt;p&gt;假設我們從最低位數開始比較&lt;/p&gt;
&lt;p&gt;依照所比對到的元素該位數的值&lt;/p&gt;
&lt;p&gt;依序放置到相對應的位置&lt;/p&gt;
&lt;p&gt;最後整個比較完之後依序取出即可得到正確答案&lt;/p&gt;
&lt;p&gt;時間複雜度為 &lt;code&gt;O(n log_p  k)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;p 為資料字元數&lt;/p&gt;
&lt;p&gt;缺點是需要花費大量的額外空間來暫存資料&lt;/p&gt;
&lt;p&gt;若n 很大, 但是p 固定或很小&lt;/p&gt;
&lt;p&gt;則此演算法十分有效率&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/radix_sort/radix_sort.java" target="_blank"&gt;radix sort – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_radix_sort.html</guid></item><item><title>[sort] selection sort</title><link>http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_selection_sort.html</link><description>&lt;p&gt;selection sort 是一種 internal sort&lt;/p&gt;
&lt;p&gt;適合小資料或已有初步排序的資料使用&lt;/p&gt;
&lt;p&gt;worst case 的時間複雜度為 &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要由小排到大&lt;/p&gt;
&lt;p&gt;其核心概念為每次 scan 時選擇一個最小的元素&lt;/p&gt;
&lt;p&gt;並與目前的位置的元素交換&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/selection_sort/selection_sort.java" target="_blank"&gt;程式碼 – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_selection_sort.html</guid></item><item><title>[sort] shell sort</title><link>http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_shell_sort.html</link><description>&lt;p&gt;shell sort 是 insertion sort 的改良版&lt;/p&gt;
&lt;p&gt;average case 的時間複雜度為 &lt;code&gt;O(n ^ 3/2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;屬於internal sort, 穩定排序&lt;/p&gt;
&lt;p&gt;目的是為了減少 insertion sort 的搬移次數&lt;/p&gt;
&lt;p&gt;其核心概念為將要排序的數依&lt;font color="red"&gt;劃分數&lt;/font&gt;來分群&lt;/p&gt;
&lt;p&gt;最簡單的做法就是設定劃分數為2&lt;/p&gt;
&lt;p&gt;因此如果我們有8筆資料的話我們就可以分成4群  (4 = 8 / 2)&lt;/p&gt;
&lt;p&gt;而分別做完一次 insertion sort 之後&lt;/p&gt;
&lt;p&gt;再將劃分數 double, 也就是變成4&lt;/p&gt;
&lt;p&gt;此時我們只會劃分為2群 (2 = 8 / 2 / 2)&lt;/p&gt;
&lt;p&gt;依此類推&lt;/p&gt;
&lt;p&gt;直到分群結束為止&lt;/p&gt;
&lt;p&gt;而劃分的方式是採取間隔的方式來取元素&lt;/p&gt;
&lt;p&gt;舉例來說如果我們有8個元素&lt;/p&gt;
&lt;p&gt;63, 92, 27, 36, 45, 71, 58, 7&lt;/p&gt;
&lt;p&gt;因此我們亦開始會得到 {63,45}, {92,71}, {27,58} 以及{36,7} 4 群&lt;/p&gt;
&lt;p&gt;依此類推&lt;/p&gt;
&lt;p&gt;如此我們就可以減少insertion sort 的搬移次數&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/shell_sort/shell_sort.java" target="_blank"&gt;Array版 – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_shell_sort.html</guid></item><item><title>[sublime text] 安裝 livereload</title><link>http://yljh21328.github.io/blog/posts/2014/07/sublime-text/[sublime_text]_install_livereload.html</link><description>&lt;p&gt;LiveReload 是一個好用的 plugin&lt;/p&gt;
&lt;p&gt;每次我們改完網頁之後都要按重新整理&lt;/p&gt;
&lt;p&gt;LiveReload 可以自動幫我們完成這件事情&lt;/p&gt;
&lt;p&gt;安裝 livereload 分為兩個階段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安裝 Sublime text plugin:&lt;/p&gt;
&lt;p&gt;使用 Package Control 來找 livereload 之後安裝即可&lt;/p&gt;
&lt;p&gt;裝完之後記得重開，沒安裝 Package Control 的人請先參考這篇 -&amp;gt; &lt;a href="http://yljh21328.github.io/blog/posts/2014/07/sublime-text/[sublime_text]_install_package_control.html" target="_blank"&gt;[安裝Package Control]&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 Chrome extension:&lt;/p&gt;
&lt;p&gt;在Chrome 的擴充功能中安裝 livereload&lt;/p&gt;
&lt;p&gt;然後記得點選右上角的小圖示開啟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sublime-text/[sublime_text]_install_livereload.html</guid></item><item><title>[sublime text] 安裝 Package Control</title><link>http://yljh21328.github.io/blog/posts/2014/07/sublime-text/[sublime_text]_install_package_control.html</link><description>&lt;p&gt;Package Control 是一個方便管理套件的 plugin&lt;/p&gt;
&lt;p&gt;在 Sublime text 2 裡， 往往我們都要透過 &lt;code&gt;Menu -&amp;gt; Preference -&amp;gt; Browse Packages&lt;/code&gt; 來瀏覽我們所安裝的套件&lt;/p&gt;
&lt;p&gt;而如果透過 Package Control 就可以很快的找尋套件以及安裝&lt;/p&gt;
&lt;p&gt;透過 &lt;code&gt;Ctrl + `&lt;/code&gt; 可以開啟 Sublime text 的 cmd&lt;/p&gt;
&lt;p&gt;再透過執行 Package Control 官網所提供的 script 後重開Sublime text 即可完成&lt;/p&gt;
&lt;p&gt;另外一個方法是在 Packages 的資料夾中自創資料夾 Package Control&lt;/p&gt;
&lt;p&gt;再從官網下載解壓縮到裡面即可&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kevintsengtw.blogspot.tw/2012/02/sublime-text-2-part3-package-control.html#.U5fcxd_FsUQ" target="_blank"&gt;資料來源&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sublime-text/[sublime_text]_install_package_control.html</guid></item><item><title>[latex] 在 lubuntu 13.10 上安裝 texlive 與 texstudio</title><link>http://yljh21328.github.io/blog/posts/2014/07/latex/[latex]_latex_install.html</link><description>&lt;p&gt;tex 是一個專業的排版格式，通常用來寫論文&lt;/p&gt;
&lt;p&gt;而 texlive 是一個用來編譯 tex 的套件&lt;/p&gt;
&lt;p&gt;texstudio 則是一套用來寫 tex 的編輯器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.tug.org/texlive/" target="_blank"&gt;texlive 官網&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://texstudio.sourceforge.net/" target="_blank"&gt;texstudio 官網&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面兩個連結可以下載 texlive 以及 texstudio&lt;/p&gt;
&lt;p&gt;要先安裝 texlive 或 texstudio 都可以&lt;/p&gt;
&lt;h3&gt;安裝 texlive&lt;/h3&gt;
&lt;p&gt;安裝 texlive 只要解壓縮後執行 &lt;code&gt;sudo ./install-tl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然後提示界面輸入 &lt;code&gt;i&lt;/code&gt; 後按確認即可安裝&lt;/p&gt;
&lt;p&gt;大概要等上 15 ~ 20 分鐘&lt;/p&gt;
&lt;p&gt;安裝完之後在 &lt;code&gt;~/.bashrc&lt;/code&gt; 的最後面加上 &lt;code&gt;export PATH=/usr/local/texlive/2014/bin/i386-linux:$PATH &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;PATH 會因為安裝路徑有異，要仔細注意&lt;/p&gt;
&lt;p&gt;存檔之後記得下 &lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;安裝 texstudio&lt;/h3&gt;
&lt;p&gt;從官網依照自己的版本下載完之後解壓縮&lt;/p&gt;
&lt;p&gt;利用 &lt;code&gt;dpkg -i xxx.deb&lt;/code&gt; 安裝即可&lt;/p&gt;
&lt;p&gt;如果有相依性的問題，則改用 &lt;code&gt; gdebi xxx.deb&lt;/code&gt; 來安裝&lt;/p&gt;
&lt;p&gt;gdebi 可以用來解相依性的問題&lt;/p&gt;
&lt;p&gt;如果打開 texstudio 上邊的功能列按鈕都消失了&lt;/p&gt;
&lt;p&gt;請安裝 &lt;code&gt;sudo apt-get install libqt4-svg&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安裝完之後請設定 compiler 以及 viewer&lt;/p&gt;
&lt;p&gt;&lt;code&gt;options -&amp;gt; configure texstudio -&amp;gt;  Build -&amp;gt; Default Compiler -&amp;gt; XeLaTex&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;options -&amp;gt; configure texstudio -&amp;gt;  Commands -&amp;gt; XeLaTex&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;XeLatex 編譯出來是 pdf檔，需要比較多時間，適合最後腳交給老師的時候用&lt;/p&gt;
&lt;p&gt;而用 latex 編譯出來是 dvi檔，比較快，適合撰寫的時候使用&lt;/p&gt;
&lt;p&gt;用 pdf viewer 的後不會有問題&lt;/p&gt;
&lt;p&gt;而如果是 dvi viewer，則可能會出錯&lt;/p&gt;
&lt;p&gt;lubuntu 預設是用 evince 來開 dvi檔&lt;/p&gt;
&lt;p&gt;而 evince 會抓不到 texlive 的檔案&lt;/p&gt;
&lt;p&gt;所以要再安裝 texlive-binaries&lt;/p&gt;
&lt;p&gt;可以下 &lt;code&gt;sudo apt-get install texlive-binaries&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如此就能成功編譯&lt;/p&gt;
&lt;p&gt;參考連結：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://askubuntu.com/questions/400975/some-icons-symbols-in-texstudio-are-missing" target="_blank"&gt;http://askubuntu.com/questions/400975/some-icons-symbols-in-texstudio-are-missing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tex.stackexchange.com/questions/54403/which-dvi-viewer-on-linux" target="_blank"&gt;http://tex.stackexchange.com/questions/54403/which-dvi-viewer-on-linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/latex/[latex]_latex_install.html</guid></item><item><title>[linux] ubuntu 架設 ftp (使用vsftp)</title><link>http://yljh21328.github.io/blog/posts/2014/07/linux/[linux]_ftp_(vsftp).html</link><description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安裝指令:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install vsftpd&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;確認是否安裝成功:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netstat -tul | grep ftp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果有出現 &lt;code&gt;Listen&lt;/code&gt; 即為安裝成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改設定檔:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo vim /etc/vsftpd.conf&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#接受匿名用戶&lt;/span&gt;
&lt;span class="nv"&gt;anonymous_enable&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;NO
&lt;span class="c"&gt;#接受本地用戶&lt;/span&gt;
&lt;span class="nv"&gt;local_enable&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YES
&lt;span class="c"&gt;#可以上傳(全局控制).若想要匿名用戶也可上傳則需要設置&lt;/span&gt;
&lt;span class="c"&gt;#anon_upload_enable=YES,若想要匿名用戶可以建立目錄&lt;/span&gt;
&lt;span class="c"&gt;#則需要anon_mkdir_write_enable=YES.&lt;/span&gt;
&lt;span class="c"&gt;#這裡禁止匿名用戶上傳,所以不設置這兩項.&lt;/span&gt;
&lt;span class="nv"&gt;write_enable&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YES
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改完記得重新啟動:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo /etc/init.d/vsftpd restart&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://blog.udn.com/nigerchen/2261345" target="_blank"&gt;參考來源&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/linux/[linux]_ftp_(vsftp).html</guid></item><item><title>[linux] 安裝 lubuntu 13.10</title><link>http://yljh21328.github.io/blog/posts/2014/07/linux/[linux]_lubuntu_install.html</link><description>&lt;p&gt;在這邊我安裝的是 lubuntu 13.10 64bit&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://cdimage.ubuntu.com/lubuntu/releases/13.10/release/lubuntu-13.10-desktop-amd64.iso" target="_blank"&gt;lubuntu 13.10 64-bit 載點&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有幾個需要注意的地方&lt;/p&gt;
&lt;p&gt;首先先將 lubuntu 的光碟放進光碟機&lt;/p&gt;
&lt;p&gt;然後再開機時選擇用光碟機開機&lt;/p&gt;
&lt;p&gt;進去之後請選擇用 &lt;code&gt;中文&lt;/code&gt; 的方式安裝&lt;/p&gt;
&lt;p&gt;如果你安裝的是英文語系的話，那麼到時候你的中文支援會非常的不完整&lt;/p&gt;
&lt;p&gt;但是如果你安裝時是用中文安裝的話，到時候安裝的加目錄可以切換回英文的目錄&lt;/p&gt;
&lt;p&gt;在磁碟分割的時候可以選擇一個空的區域(我是切100G)，格式化成 &lt;code&gt;ext4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;並掛載給根目錄 &lt;code&gt;/&lt;/code&gt; 即可&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swap&lt;/code&gt;的話就看自己要不要切了，現在的記憶體空間應該都是夠用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;記得如果要裝雙系統的話要先裝 windows 再裝 ubuntu，不然開機選單會讀不到&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安裝完之後有幾件事情要注意一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;將中文目錄改回英文名稱&lt;/p&gt;
&lt;p&gt;1.echo $LANG&lt;/p&gt;
&lt;p&gt;2.export LANG=en_US&lt;/p&gt;
&lt;p&gt;3.xdg-user-dirs-gtk-update&lt;/p&gt;
&lt;p&gt;4.將第一步驟得到的 $LANG 給 export 回去&lt;/p&gt;
&lt;p&gt;參考來源: &lt;a href="http://freedom-heero.blogspot.tw/2012/11/ubuntu.html" target="_blank"&gt;蒼天之劍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;連接網路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新語言支援 language support&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新系統： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先下 &lt;code&gt;sudo apt-get update&lt;/code&gt; 更新軟體源再下 &lt;code&gt;sudo apt-get upgrade&lt;/code&gt; 更新套件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝常用軟體：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filezilla &lt;code&gt;sudo apt-get install filezilla&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;aptitude &lt;code&gt;sudo apt-get install aptitude&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;lamp sudo &lt;code&gt;apt-get install lamp-server^&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;phpmyadmin &lt;code&gt;&lt;a href="http://www.phpmyadmin.net/home_page/index.php" target="_blank"&gt;phpmyadmin 官網&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;vim sudo &lt;code&gt;apt-get intsll vim&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ssh sudo &lt;code&gt;apt-get install openssh-server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;git sudo &lt;code&gt;apt-get install git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新設定檔&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.bashrc&lt;/li&gt;
&lt;li&gt;.vimrc&lt;/li&gt;
&lt;li&gt;.vim&lt;/li&gt;
&lt;li&gt;.gitignore&lt;/li&gt;
&lt;li&gt;.ssh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/linux/[linux]_lubuntu_install.html</guid></item><item><title>[linux] recursively chmod</title><link>http://yljh21328.github.io/blog/posts/2014/07/linux/[linux]_recursively_chmod.html</link><description>&lt;p&gt;chmod 透過 -R 可以遞迴地更改資料夾及檔案的權限&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod -R 777 /home/shi/Desktop/Host/lab/txp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.blog.highub.com/shell/linux-chmod-777-recursively/" target="_blank"&gt;資料來源&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/linux/[linux]_recursively_chmod.html</guid></item><item><title>[linux] userdel: user xxx is currently logged in</title><link>http://yljh21328.github.io/blog/posts/2014/07/linux/[linux]_userdel_xxx_is_currently_logged_in.html</link><description>&lt;p&gt;&lt;code&gt;userdel xxx&lt;/code&gt; 可以刪除使用者帳號&lt;/p&gt;
&lt;p&gt;&lt;code&gt;userdel -r xxx&lt;/code&gt; 連家目錄也刪掉&lt;/p&gt;
&lt;p&gt;如果遇到 user xxx is currently logged in&lt;/p&gt;
&lt;p&gt;則用 &lt;code&gt;userdel -rf xxx&lt;/code&gt; 強制刪除即可&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_4888f8810100vcg9.html" target="_blank"&gt;資料來源&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/linux/[linux]_userdel_xxx_is_currently_logged_in.html</guid></item><item><title>[git] 刪除遠端的branch</title><link>http://yljh21328.github.io/blog/posts/2014/07/git/[git]_delete_remote_branch.html</link><description>&lt;p&gt;要刪除本地端的 branch 非常容易&lt;/p&gt;
&lt;p&gt;先切換到其他的branch&lt;/p&gt;
&lt;p&gt;然後下 &lt;code&gt;git branch -d  branch-name&lt;/code&gt; 即可&lt;/p&gt;
&lt;p&gt;然而如果要刪除遠端的branch&lt;/p&gt;
&lt;p&gt;則必須下 &lt;code&gt;git push branch --delete branch-name&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/git/[git]_delete_remote_branch.html</guid></item><item><title>[hash] linear hashing</title><link>http://yljh21328.github.io/blog/posts/2014/07/hash/[hash]_linear_hashing.html</link><description>&lt;p&gt;linear hashing 是一種 &lt;font style="color:red;"&gt;dynamic hashing&lt;/font&gt; 的方法&lt;/p&gt;
&lt;p&gt;其儲存的欄位分為兩種 primary page, overflow page&lt;/p&gt;
&lt;p&gt;並設N 為初始的 bucket 數&lt;/p&gt;
&lt;p&gt;h_level (key) = key mod [N * 2 ^ N]&lt;/p&gt;
&lt;p&gt;並存在一個 point Next 指向下一個要分割的 bucket&lt;/p&gt;
&lt;p&gt;而 linear hashing 存在一個 utilization 的機制&lt;/p&gt;
&lt;p&gt;超過 utilization 時則 split bucket&lt;/p&gt;
&lt;p&gt;其演算法如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;給定&lt;/span&gt; &lt;span class="nx"&gt;N&lt;/span&gt; &lt;span class="err"&gt;為初始的&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="err"&gt;數&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;point&lt;/span&gt; &lt;span class="nx"&gt;Next&lt;/span&gt; &lt;span class="err"&gt;指向第&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="err"&gt;個&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt;

&lt;span class="nx"&gt;utilization&lt;/span&gt; &lt;span class="nx"&gt;is&lt;/span&gt; &lt;span class="nx"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nx"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;

&lt;span class="nx"&gt;level&lt;/span&gt; &lt;span class="err"&gt;為&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;透過&lt;/span&gt; &lt;span class="nx"&gt;hash&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="err"&gt;來將&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt; &lt;span class="nx"&gt;insert&lt;/span&gt; &lt;span class="err"&gt;到&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="err"&gt;之中&lt;/span&gt;

&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;檢查&lt;/span&gt; &lt;span class="nx"&gt;utilization&lt;/span&gt; &lt;span class="err"&gt;是否超過&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;如果超過則&lt;/span&gt; &lt;span class="nx"&gt;split&lt;/span&gt; &lt;span class="nx"&gt;next&lt;/span&gt; &lt;span class="err"&gt;指到的&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt;

&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;重複步驟&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="err"&gt;直到&lt;/span&gt; &lt;span class="nx"&gt;utilization&lt;/span&gt; &lt;span class="err"&gt;降到&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="err"&gt;以下&lt;/span&gt;

&lt;span class="err"&gt;如此可成功地將所有的&lt;/span&gt;&lt;span class="nx"&gt;number&lt;/span&gt; &lt;span class="nx"&gt;insert&lt;/span&gt; &lt;span class="err"&gt;到&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="err"&gt;之中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而split 的細節是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;將&lt;/span&gt;&lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="err"&gt;中的值去&lt;/span&gt; &lt;span class="nx"&gt;mod&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="err"&gt;的倍數&lt;/span&gt;

&lt;span class="err"&gt;如果無法分開&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;則挑選大一點的&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;的倍數&lt;/span&gt;

&lt;span class="nx"&gt;split&lt;/span&gt; &lt;span class="err"&gt;結束之後將&lt;/span&gt; &lt;span class="nx"&gt;next&lt;/span&gt; &lt;span class="err"&gt;指向下一個&lt;/span&gt;&lt;span class="nx"&gt;bucket&lt;/span&gt;

&lt;span class="err"&gt;如果下一個&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nx"&gt;N&lt;/span&gt;

&lt;span class="err"&gt;則將&lt;/span&gt; &lt;span class="nx"&gt;next&lt;/span&gt; &lt;span class="err"&gt;歸&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;而&lt;/span&gt; &lt;span class="nx"&gt;level&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="err"&gt;要再&lt;/span&gt;&lt;span class="nx"&gt;insert&lt;/span&gt; &lt;span class="err"&gt;新的&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt; &lt;span class="err"&gt;時則使用新的&lt;/span&gt; &lt;span class="nx"&gt;hash&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="err"&gt;來&lt;/span&gt; &lt;span class="nx"&gt;hash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://yljh21328.github.io/blog/pdf/EDHashing.pdf" target="_blank"&gt;詳細教學與範例&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/hash/[hash]_linear_hashing.html</guid></item><item><title>[hash] linear probing</title><link>http://yljh21328.github.io/blog/posts/2014/07/hash/[hash]_linear_probing.html</link><description>&lt;p&gt;linear probing 是一種用來碰撞處理的策略&lt;/p&gt;
&lt;p&gt;如果hash 過去的欄位已有值存在&lt;/p&gt;
&lt;p&gt;則往後尋找直到遇到第一個空的欄位為止&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/HASH/linear_probing/linear_probing.java" target="_blank"&gt;linear probing – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/hash/[hash]_linear_probing.html</guid></item><item><title>[hash] rehashing</title><link>http://yljh21328.github.io/blog/posts/2014/07/hash/[hash]_rehashing.html</link><description>&lt;p&gt;rehashing 的概念是在hash 的過程中如果遇到 collision 與 overflow&lt;/p&gt;
&lt;p&gt;則再改用另外一種 hash function 來hash&lt;/p&gt;
&lt;p&gt;而在此我們使用 &lt;font style="color:red;"&gt;linked list&lt;/font&gt; 來解決 collision 與 overflow 的問題&lt;/p&gt;
&lt;p&gt;透過不斷的往後串即可&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/HASH/rehashing/rehashing.java" target="_blank"&gt;rehashing – JAVA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而下面的範例是加上搜尋的功能&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/HASH/rehashing_search/rehashing_search.java" target="_blank"&gt;rehashing with search – JAVA&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/hash/[hash]_rehashing.html</guid></item><item><title>[css] 編號清單加大行距</title><link>http://yljh21328.github.io/blog/posts/2014/07/css/ol_line_height.html</link><description>&lt;p&gt;設定 &lt;code&gt;line-height&lt;/code&gt; 即可&lt;/p&gt;
&lt;script src="https://gist.github.com/yljh21328/f66bb72a267f651f6a25.js"&gt;&lt;/script&gt;

&lt;p&gt;長得像這樣：&lt;/p&gt;
&lt;ol style="line-height:20px;"&gt;
    &lt;li&gt;第一項&lt;/li&gt;
    &lt;li&gt;第二項&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Yang</dc:creator><pubDate>Fri, 11 Jul 2014 22:48:12 +0800</pubDate><guid>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/css/ol_line_height.html</guid></item></channel></rss>