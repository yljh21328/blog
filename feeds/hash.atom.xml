<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Chris Yang | 學習筆記</title><link href="http://yljh21328.github.io/blog/" rel="alternate"></link><link href="http://yljh21328.github.io/blog/feeds/hash.atom.xml" rel="self"></link><id>http://yljh21328.github.io/blog/</id><updated>2014-06-19T12:39:11+08:00</updated><entry><title>[hash] linear hashing</title><link href="http://yljh21328.github.io/blog/posts/2014/06/hash/[hash]_linear_hashing.html" rel="alternate"></link><updated>2014-06-19T12:39:11+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io/blog,2014-06-19:posts/2014/06/hash/[hash]_linear_hashing.html</id><summary type="html">&lt;p&gt;linear hashing 是一種 &lt;font style="color:red;"&gt;dynamic hashing&lt;/font&gt; 的方法&lt;/p&gt;
&lt;p&gt;其儲存的欄位分為兩種 primary page, overflow page&lt;/p&gt;
&lt;p&gt;並設N 為初始的 bucket 數&lt;/p&gt;
&lt;p&gt;h_level (key) = key mod [N * 2 ^ N]&lt;/p&gt;
&lt;p&gt;並存在一個 point Next 指向下一個要分割的 bucket&lt;/p&gt;
&lt;p&gt;而 linear hashing 存在一個 utilization 的機制&lt;/p&gt;
&lt;p&gt;超過 utilization 時則 split bucket&lt;/p&gt;
&lt;p&gt;其演算法如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;給定&lt;/span&gt; &lt;span class="nx"&gt;N&lt;/span&gt; &lt;span class="err"&gt;為初始的&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="err"&gt;數&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;point&lt;/span&gt; &lt;span class="nx"&gt;Next&lt;/span&gt; &lt;span class="err"&gt;指向第&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="err"&gt;個&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt;

&lt;span class="nx"&gt;utilization&lt;/span&gt; &lt;span class="nx"&gt;is&lt;/span&gt; &lt;span class="nx"&gt;between&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nx"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;

&lt;span class="nx"&gt;level&lt;/span&gt; &lt;span class="err"&gt;為&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;透過&lt;/span&gt; &lt;span class="nx"&gt;hash&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="err"&gt;來將&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt; &lt;span class="nx"&gt;insert&lt;/span&gt; &lt;span class="err"&gt;到&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="err"&gt;之中&lt;/span&gt;

&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;檢查&lt;/span&gt; &lt;span class="nx"&gt;utilization&lt;/span&gt; &lt;span class="err"&gt;是否超過&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;如果超過則&lt;/span&gt; &lt;span class="nx"&gt;split&lt;/span&gt; &lt;span class="nx"&gt;next&lt;/span&gt; &lt;span class="err"&gt;指到的&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt;

&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;重複步驟&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="err"&gt;直到&lt;/span&gt; &lt;span class="nx"&gt;utilization&lt;/span&gt; &lt;span class="err"&gt;降到&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="err"&gt;以下&lt;/span&gt;

&lt;span class="err"&gt;如此可成功地將所有的&lt;/span&gt;&lt;span class="nx"&gt;number&lt;/span&gt; &lt;span class="nx"&gt;insert&lt;/span&gt; &lt;span class="err"&gt;到&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="err"&gt;之中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而split 的細節是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;將&lt;/span&gt;&lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="err"&gt;中的值去&lt;/span&gt; &lt;span class="nx"&gt;mod&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="err"&gt;的倍數&lt;/span&gt;

&lt;span class="err"&gt;如果無法分開&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;則挑選大一點的&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;的倍數&lt;/span&gt;

&lt;span class="nx"&gt;split&lt;/span&gt; &lt;span class="err"&gt;結束之後將&lt;/span&gt; &lt;span class="nx"&gt;next&lt;/span&gt; &lt;span class="err"&gt;指向下一個&lt;/span&gt;&lt;span class="nx"&gt;bucket&lt;/span&gt;

&lt;span class="err"&gt;如果下一個&lt;/span&gt; &lt;span class="nx"&gt;bucket&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nx"&gt;N&lt;/span&gt;

&lt;span class="err"&gt;則將&lt;/span&gt; &lt;span class="nx"&gt;next&lt;/span&gt; &lt;span class="err"&gt;歸&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;而&lt;/span&gt; &lt;span class="nx"&gt;level&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="err"&gt;要再&lt;/span&gt;&lt;span class="nx"&gt;insert&lt;/span&gt; &lt;span class="err"&gt;新的&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt; &lt;span class="err"&gt;時則使用新的&lt;/span&gt; &lt;span class="nx"&gt;hash&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="err"&gt;來&lt;/span&gt; &lt;span class="nx"&gt;hash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="{filename}/pdf/EDHashing.pdf" target="_blank"&gt;詳細教學與範例&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>[hash] linear probing</title><link href="http://yljh21328.github.io/blog/posts/2014/06/hash/[hash]_linear_probing.html" rel="alternate"></link><updated>2014-06-19T12:39:11+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io/blog,2014-06-19:posts/2014/06/hash/[hash]_linear_probing.html</id><summary type="html">&lt;p&gt;linear probing 是一種用來碰撞處理的策略&lt;/p&gt;
&lt;p&gt;如果hash 過去的欄位已有值存在&lt;/p&gt;
&lt;p&gt;則往後尋找直到遇到第一個空的欄位為止&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/HASH/linear_probing/linear_probing.java" target="_blank"&gt;linear probing – JAVA&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>[hash] rehashing</title><link href="http://yljh21328.github.io/blog/posts/2014/06/hash/[hash]_rehashing.html" rel="alternate"></link><updated>2014-06-19T12:39:11+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io/blog,2014-06-19:posts/2014/06/hash/[hash]_rehashing.html</id><summary type="html">&lt;p&gt;rehashing 的概念是在hash 的過程中如果遇到 collision 與 overflow&lt;/p&gt;
&lt;p&gt;則再改用另外一種 hash function 來hash&lt;/p&gt;
&lt;p&gt;而在此我們使用 &lt;font style="color:red;"&gt;linked list&lt;/font&gt; 來解決 collision 與 overflow 的問題&lt;/p&gt;
&lt;p&gt;透過不斷的往後串即可&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/HASH/rehashing/rehashing.java" target="_blank"&gt;rehashing – JAVA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而下面的範例是加上搜尋的功能&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/HASH/rehashing_search/rehashing_search.java" target="_blank"&gt;rehashing with search – JAVA&lt;/a&gt;&lt;/p&gt;</summary></entry></feed>