<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Chris Yang | 學習筆記</title><link href="http://yljh21328.github.io/blog/" rel="alternate"></link><link href="http://yljh21328.github.io/blog/feeds/sort.atom.xml" rel="self"></link><id>http://yljh21328.github.io/blog/</id><updated>2014-07-11T22:48:12+08:00</updated><entry><title>[sort] bubble sort</title><link href="http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_bubble_sort.html" rel="alternate"></link><updated>2014-07-11T22:48:12+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_bubble_sort.html</id><summary type="html">&lt;p&gt;bubble sort 是一種 internal sort&lt;/p&gt;
&lt;p&gt;適合資料量小或已經有初步排序的資料使用&lt;/p&gt;
&lt;p&gt;其 worst case 為 &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果是要由小排到大&lt;/p&gt;
&lt;p&gt;核心概念是由前往後兩兩比對，若前者大於後者則交換&lt;/p&gt;
&lt;p&gt;並由較大者繼續與後面的元素兩兩比對。&lt;/p&gt;
&lt;p&gt;每scan一次能確定一個元素的最後位置&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/traditional_bubble_sort/bubble_sort.java" target="_blank"&gt;傳統版 - JAVA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/better_bubble_sort/bubble_sort.java" target="_blank"&gt;改良版 - JAVA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在改良版的bubble sort 裡加入了 flag 來判斷該次 scan 有沒有做 swap&lt;/p&gt;
&lt;p&gt;如果沒有則不需要額外的 scan&lt;/p&gt;</summary></entry><entry><title>[sort] heap sort</title><link href="http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_heap_sort.html" rel="alternate"></link><updated>2014-07-11T22:48:12+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_heap_sort.html</id><summary type="html">&lt;p&gt;heap sort 使用了 heap 來幫助我們做sort 的工作&lt;/p&gt;
&lt;p&gt;時間複雜度為 &lt;code&gt;O(n logn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;為穩定排序法&lt;/p&gt;
&lt;p&gt;核心概念為運用heap 的特性&lt;/p&gt;
&lt;p&gt;假設我們有一個 size 為 n 的 heap&lt;/p&gt;
&lt;p&gt;每次將root 與heap 的最後一個位置交換&lt;/p&gt;
&lt;p&gt;然後再執行一次 size 為 n-1 的 &lt;font style="color:red;"&gt;heapify()&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;重複此動作直至所有元素都被排序完為止&lt;/p&gt;
&lt;p&gt;在實作的部分&lt;/p&gt;
&lt;p&gt;我們習慣將存data 的陣列的第0個位置空出來&lt;/p&gt;
&lt;p&gt;從第1個位置開始存&lt;/p&gt;
&lt;p&gt;這樣才能符合 heap 的特性&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/heap_sort/heap_sort.java" target="_blank"&gt;heap sort – JAVA&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>[sort] insertion sort</title><link href="http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_insertion_sort.html" rel="alternate"></link><updated>2014-07-11T22:48:12+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_insertion_sort.html</id><summary type="html">&lt;p&gt;insertion sort 是一個 internal sort&lt;/p&gt;
&lt;p&gt;其worst case 的時間複雜度為 &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要由小排到大&lt;/p&gt;
&lt;p&gt;核心概念為逐次檢查元素與其之前元素的大小&lt;/p&gt;
&lt;p&gt;如果比之前的元素小則將前面的元素往後推&lt;/p&gt;
&lt;p&gt;直到找到正確的位置為止&lt;/p&gt;
&lt;p&gt;因為在 scan 的過程中會發生多次的搬移&lt;/p&gt;
&lt;p&gt;所以如果以 linked list 來實作的話會快很多&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/insertion_sort/insertion_sort.java" target="_blank"&gt;Array版 – Java&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>[sort] merge sort</title><link href="http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_merge_sort.html" rel="alternate"></link><updated>2014-07-11T22:48:12+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_merge_sort.html</id><summary type="html">&lt;p&gt;merge sort 是一個 external sort&lt;/p&gt;
&lt;p&gt;其時間複雜度為 &lt;code&gt;O(n logn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;適合合併多個檔案並排序&lt;/p&gt;
&lt;p&gt;如果有兩個檔案要做排序&lt;/p&gt;
&lt;p&gt;核心概念是先分別對這倆個檔案做內部排序&lt;/p&gt;
&lt;p&gt;之後再分別用指標指著這兩個檔案&lt;/p&gt;
&lt;p&gt;依序讀入後比較&lt;/p&gt;
&lt;p&gt;並將較小的元素給存到一個新的 sequence當中&lt;/p&gt;
&lt;p&gt;而該檔案繼續讀下一個元素&lt;/p&gt;
&lt;p&gt;直到讀完為止&lt;/p&gt;
&lt;p&gt;而如果其中一個檔案先讀完&lt;/p&gt;
&lt;p&gt;則直接將另外一個檔案的內容依序讀入sequence&lt;/p&gt;
&lt;p&gt;直至兩個檔案都讀完為止&lt;/p&gt;
&lt;p&gt;如此我們就可以得到一個排序過後的sequence&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/tree/master/SORT/direct_merge_sort" target="_blank"&gt;直接merge – JAVA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/tree/master/SORT/complete_merge_sort" target="_blank"&gt;分割檔案後再merge – JAVA&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>[sort] quick sort</title><link href="http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_quick_sort.html" rel="alternate"></link><updated>2014-07-11T22:48:12+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_quick_sort.html</id><summary type="html">&lt;p&gt;quick sort 是一個內部排序法&lt;/p&gt;
&lt;p&gt;平均時間複雜度為 &lt;code&gt;O(n logn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;worst case 的時間複雜度為 O(n^2)&lt;/p&gt;
&lt;p&gt;採取的是 &lt;font stlye="color:red;"&gt;divide and conquer&lt;/font&gt; 的模式來解決問題&lt;/p&gt;
&lt;p&gt;核心概念是先設整個序列的第一個值為K&lt;/p&gt;
&lt;p&gt;然後從左至右找到一個比K 大的元素 Ki&lt;/p&gt;
&lt;p&gt;並從右到左找到一個比K小的元素Kj&lt;/p&gt;
&lt;p&gt;找到後就彼此交換&lt;/p&gt;
&lt;p&gt;直到 i &amp;lt; j 時&lt;/p&gt;
&lt;p&gt;此時再將 Kj 與 K 的位置交換&lt;/p&gt;
&lt;p&gt;結束這回合&lt;/p&gt;
&lt;p&gt;此時便能決定K的位置&lt;/p&gt;
&lt;p&gt;然後再利用divide and conquer 來解決左邊與右邊尚未解決的subsequence&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/quick_sort/quick_sort.java" target="_blank"&gt;quick sort – JAVA&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>[sort] radix sort</title><link href="http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_radix_sort.html" rel="alternate"></link><updated>2014-07-11T22:48:12+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_radix_sort.html</id><summary type="html">&lt;p&gt;radix sort 是一個不需要兩兩比較元素的一種排序法&lt;/p&gt;
&lt;p&gt;其核心概念是透過分配每一個元素到適當的位置&lt;/p&gt;
&lt;p&gt;我們可以先從最低位數開始比較或從最高位數開始比較都可以&lt;/p&gt;
&lt;p&gt;假設我們從最低位數開始比較&lt;/p&gt;
&lt;p&gt;依照所比對到的元素該位數的值&lt;/p&gt;
&lt;p&gt;依序放置到相對應的位置&lt;/p&gt;
&lt;p&gt;最後整個比較完之後依序取出即可得到正確答案&lt;/p&gt;
&lt;p&gt;時間複雜度為 &lt;code&gt;O(n log_p  k)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;p 為資料字元數&lt;/p&gt;
&lt;p&gt;缺點是需要花費大量的額外空間來暫存資料&lt;/p&gt;
&lt;p&gt;若n 很大, 但是p 固定或很小&lt;/p&gt;
&lt;p&gt;則此演算法十分有效率&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/radix_sort/radix_sort.java" target="_blank"&gt;radix sort – JAVA&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>[sort] selection sort</title><link href="http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_selection_sort.html" rel="alternate"></link><updated>2014-07-11T22:48:12+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_selection_sort.html</id><summary type="html">&lt;p&gt;selection sort 是一種 internal sort&lt;/p&gt;
&lt;p&gt;適合小資料或已有初步排序的資料使用&lt;/p&gt;
&lt;p&gt;worst case 的時間複雜度為 &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要由小排到大&lt;/p&gt;
&lt;p&gt;其核心概念為每次 scan 時選擇一個最小的元素&lt;/p&gt;
&lt;p&gt;並與目前的位置的元素交換&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/selection_sort/selection_sort.java" target="_blank"&gt;程式碼 – JAVA&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>[sort] shell sort</title><link href="http://yljh21328.github.io/blog/posts/2014/07/sort/[sort]_shell_sort.html" rel="alternate"></link><updated>2014-07-11T22:48:12+08:00</updated><author><name>Chris Yang</name></author><id>tag:yljh21328.github.io,2014-07-11:blog/posts/2014/07/sort/[sort]_shell_sort.html</id><summary type="html">&lt;p&gt;shell sort 是 insertion sort 的改良版&lt;/p&gt;
&lt;p&gt;average case 的時間複雜度為 &lt;code&gt;O(n ^ 3/2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;屬於internal sort, 穩定排序&lt;/p&gt;
&lt;p&gt;目的是為了減少 insertion sort 的搬移次數&lt;/p&gt;
&lt;p&gt;其核心概念為將要排序的數依&lt;font color="red"&gt;劃分數&lt;/font&gt;來分群&lt;/p&gt;
&lt;p&gt;最簡單的做法就是設定劃分數為2&lt;/p&gt;
&lt;p&gt;因此如果我們有8筆資料的話我們就可以分成4群  (4 = 8 / 2)&lt;/p&gt;
&lt;p&gt;而分別做完一次 insertion sort 之後&lt;/p&gt;
&lt;p&gt;再將劃分數 double, 也就是變成4&lt;/p&gt;
&lt;p&gt;此時我們只會劃分為2群 (2 = 8 / 2 / 2)&lt;/p&gt;
&lt;p&gt;依此類推&lt;/p&gt;
&lt;p&gt;直到分群結束為止&lt;/p&gt;
&lt;p&gt;而劃分的方式是採取間隔的方式來取元素&lt;/p&gt;
&lt;p&gt;舉例來說如果我們有8個元素&lt;/p&gt;
&lt;p&gt;63, 92, 27, 36, 45, 71, 58, 7&lt;/p&gt;
&lt;p&gt;因此我們亦開始會得到 {63,45}, {92,71}, {27,58} 以及{36,7} 4 群&lt;/p&gt;
&lt;p&gt;依此類推&lt;/p&gt;
&lt;p&gt;如此我們就可以減少insertion sort 的搬移次數&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yljh21328/code_example/blob/master/SORT/shell_sort/shell_sort.java" target="_blank"&gt;Array版 – JAVA&lt;/a&gt;&lt;/p&gt;</summary></entry></feed>